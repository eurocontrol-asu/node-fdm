{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"<p> A physics-guided Neural Ordinary Differential Equation (Neural ODE) framework for aircraft flight dynamics. </p>"},{"location":"#node-fdm-at-a-glance","title":"\ud83c\udfaf node-fdm: At a Glance","text":"<p>node-fdm is a Python library designed for learning and simulation of aircraft flight dynamics.</p> <p>It couples the efficiency of Neural Ordinary Differential Equations (Neural ODE) with physical laws from aeronautics to:</p> <ul> <li>Reconstruct coherent aircraft trajectories from data (ADS-B or QAR).</li> <li>Simulate aircraft behavior through physically aware latent dynamics.</li> <li>Offer ready-to-use (OpenSky 2025, QAR) and customizable architectures.</li> <li>Enable benchmarking against established physical models such as BADA.</li> </ul> <p>This documentation will guide you through installation, core concepts, running pipelines, and extending the framework.</p>"},{"location":"#quick-start-navigation","title":"\ud83d\ude80 Quick Start &amp; Navigation","text":"<p>Start from installation, then follow the end-to-end pipelines mirrored in the repository layout.</p>"},{"location":"#start-here","title":"\ud83c\udf1f Start here","text":"<ul> <li>Installation: set up Python, optional extras, and editable installs.</li> <li>Quickstart: full workflow overview for any architecture plus the OpenSky 2025 example.</li> </ul>"},{"location":"#run-the-pipelines","title":"\ud83e\uddea Run the pipelines","text":"<ul> <li>Configure parameters: edit <code>scripts/opensky/config.yaml</code> or <code>scripts/qar/config.yaml</code> to set paths, typecodes, and hyperparameters.</li> <li>Train a model: launch <code>opensky_2025</code> or <code>qar</code> training via <code>ODETrainer</code> and monitor checkpoints.</li> <li>Run inference: load saved models with <code>NodeFDMPredictor</code>, roll out trajectories, and export predictions.</li> </ul>"},{"location":"#extend-or-customise","title":"\ud83d\udee0\ufe0f Extend or customise","text":"<ul> <li>Create an architecture: clone the OpenSky/QAR templates, declare columns, hooks, and layer stacks.</li> <li>Core concepts: learn about column groups, processing hooks, and architecture registration.</li> </ul>"},{"location":"#api-reference","title":"\ud83d\udcda API reference","text":"<ul> <li>Overview, Architectures, Data, Models, Trainer, Predictor, Package index.</li> </ul>"},{"location":"#legal-notice","title":"\ud83d\udccc Legal Notice","text":"<p>This project is distributed under the EUPL-1.2 license with specific EUROCONTROL amendments (see <code>AMENDMENT_TO_EUPL_license.md</code>).</p> <p>It is intended for research purposes only and must not be used as a regulatory or operational tool under any circumstances.</p>"},{"location":"concepts/","title":"\ud83e\udde0 Core Concepts","text":"<p>This section introduces the fundamental building blocks of node-fdm.  Understanding these concepts will help you navigate architectures, preprocess data, and extend the framework with your own models.</p>"},{"location":"concepts/#column-groups","title":"\ud83d\udd22 Column Groups","text":"<p>Each architecture organises its input and output features into well-defined column groups:</p> <ul> <li> <p><code>X_COLS</code> \u2014 State variables   Flight states used as ODE inputs and outputs.  </p> </li> <li> <p><code>U_COLS</code> \u2014 Control variables   Pilot or FMS selections, control inputs, or actuations.</p> </li> <li> <p><code>E0_COLS</code> \u2014 Environmental inputs   Exogenous variables such as wind, distances, temperatures, or air density.</p> </li> <li> <p><code>E_COLS</code> \u2014 Derived/environmental features   Outputs from physics or feature-extraction layers.</p> </li> <li> <p><code>DX_COLS</code> \u2014 Derivatives predicted by the ODE layer   Target derivatives for the Neural ODE (e.g. <code>dalt</code>, <code>dvz</code>, <code>dmass</code>).</p> </li> </ul> <p>These groups define the information flow inside an architecture.</p>"},{"location":"concepts/#architectures","title":"\ud83c\udfd7\ufe0f Architectures","text":"<p>An architecture combines physics and data-driven components:</p> <ul> <li> <p>Physics/feature layers   e.g., <code>TrajectoryLayer</code>, <code>EngineLayer</code>, or custom layers computing derived quantities.</p> </li> <li> <p>Neural ODE / Structured layers   e.g., <code>StructuredLayer</code>, which predicts the derivatives (<code>DX_COLS</code>).</p> </li> </ul> <p>Together, these layers form a stack defined in each architecture\u2019s <code>model.py</code>, where the order of layers and the mapping between column groups are specified.</p>"},{"location":"concepts/#processing-hooks","title":"\ud83d\udd27 Processing Hooks","text":"<p>Each architecture can provide two optional hooks:</p> <ul> <li> <p><code>flight_processing</code>   Augments raw data before training (e.g., computing <code>alt_diff</code>, smoothing, adding derived physics).</p> </li> <li> <p><code>segment_filtering</code>   Removes poor-quality segments or invalid training examples.</p> </li> </ul> <p>These hooks allow architectures to remain self-contained, they define not only the model, but also how the data should be prepared for it.</p>"},{"location":"concepts/#normalization-statistics","title":"\ud83d\udcd0 Normalization &amp; Statistics","text":"<p><code>SeqDataset</code> automatically computes:</p> <ul> <li>mean and standard deviation for each column  </li> <li>outlier-robust scaling (clipped at 99.5%)  </li> <li>metadata stored in <code>meta.json</code> for inference</li> </ul> <p>This ensures consistent training and inference, even when switching architectures.</p>"},{"location":"concepts/#registration-mechanism","title":"\ud83e\udde9 Registration Mechanism","text":"<p>For an architecture to be discoverable, it must be added to:</p> <p>node_fdm/architectures/mapping.py</p> <p>This mapping resolves each <code>architecture_name</code> to:</p> <ul> <li>its column groups  </li> <li>its layers  </li> <li>its processing hooks</li> </ul> <p>Without registration, trainers and predictors cannot locate your architecture.</p>"},{"location":"concepts/#creating-your-own-architecture","title":"\ud83d\ude80 Creating Your Own Architecture","text":"<p>Use the existing <code>opensky_2025</code> and <code>qar</code> folders as templates. Mirror their structure when defining:</p> <ul> <li>column groups (<code>columns.py</code>)  </li> <li>processing hooks (<code>flight_process.py</code>)  </li> <li>layer stack (<code>model.py</code>)  </li> <li>any extra physics or feature layers  </li> </ul>"},{"location":"guide/installation/","title":"\u2699\ufe0f Installation","text":"<p>This page explains how to install node-fdm, configure optional dependencies, and set up the directories used by the data pipelines.</p>"},{"location":"guide/installation/#prerequisites","title":"\ud83e\udde9 Prerequisites","text":"<p>Before installing, ensure you have:</p> <ul> <li>Python 3.11+</li> <li>OpenSky Trino access (required only if you plan to run the full OpenSky 2025 pipeline)</li> <li>Optional: BADA 4.2 model files   Set their location in the relevant <code>config.yaml</code> (<code>scripts/opensky/config.yaml</code>).</li> </ul>"},{"location":"guide/installation/#install-the-package","title":"\ud83d\udce6 Install the Package","text":"<p>From PyPI (recommended for users) - Core library: <code>pip install node-fdm</code> - With optional deps (traffic, fastmeteo, viz): <code>pip install 'node-fdm[all]'</code> - BADA baseline support (pyBADA requirements are restrictive): <code>pip install pybada --ignore-requires-python --no-deps</code> <code>pip install simplekml 'xlsxwriter&gt;=3.2.5'</code>  # pyBADA dependency</p> <p>From source (contributors) <pre><code>pip install -e .[all]      # core + traffic + fastmeteo + click + tqdm + matplotlib\n</code></pre></p>"},{"location":"guide/installation/#project-directories","title":"\ud83d\udcc1 Project Directories","text":"<p>Each pipeline has its own <code>config.yaml</code> (<code>scripts/opensky/config.yaml</code>, <code>scripts/qar/config.yaml</code>) where you define:</p> <ul> <li><code>paths.data_dir</code> \u2014 root for all data artifacts  </li> <li><code>paths.download_dir</code>, <code>preprocess_dir</code>, <code>process_dir</code>, <code>predicted_dir</code>, <code>bada_dir</code>, <code>models_dir</code>, <code>figure_dir</code> </li> <li><code>paths.era5_cache_dir</code> \u2014 local cache for meteorological fields  </li> <li><code>bada.bada_4_2_dir</code> \u2014 required if you run the BADA baseline (<code>07_bada_prediction.py</code>)</li> </ul>"},{"location":"guide/installation/#quick-check","title":"\u2714\ufe0f Quick Check","text":"<p>Verify that <code>node_fdm</code> imports correctly:</p> <pre><code>python - &lt;&lt;'PY'\nimport torch\nimport node_fdm\nprint(\"Torch:\", torch.__version__)\nprint(\"node_fdm import OK\")\n</code></pre> <p>If both lines print successfully, your installation is complete.</p>"},{"location":"guide/quickstart/","title":"Quickstart","text":"<p>This guide provides a complete overview of how to run node-fdm end-to-end. It provide the general workflow used by all architectures and the full OpenSky 2025 pipeline example. All paths assume you are at the repository root; each pipeline ships its own <code>config.yaml</code> under <code>scripts/opensky/</code> or <code>scripts/qar/</code>.</p>"},{"location":"guide/quickstart/#general-pattern-any-architecture","title":"General Pattern (Any Architecture)","text":"<p>1) Collect and prepare raw data    Ensure your raw inputs can be mapped to the architecture\u2019s <code>Column</code> definitions.</p> <p>2) Decode, resample, and clean    Build consistent time steps, decode dependent messages, and remove invalid or unusable segments.</p> <p>3) Feature enrichment    Add environmental inputs (e.g., ERA5), smoothing, and architecture-specific derived quantities.</p> <p>4) Dataset splitting    Create a file list with <code>train</code>, <code>val</code>, and <code>test</code> assignments pointing to processed parquet files.</p> <p>5) Training    Use <code>ODETrainer</code>, setting <code>architecture_name</code> to your target architecture and loading its <code>model_params</code> from <code>model.py</code>.</p> <p>6) Inference    Load checkpoints with <code>NodeFDMPredictor</code>, reuse the architecture\u2019s preprocessing hooks, and write prediction parquet files.</p> <p>7) Evaluation and visualization    Compute metrics and generate overlays for the output columns relevant to your architecture.</p>"},{"location":"guide/quickstart/#opensky-2025-ads-b-example-pipeline","title":"OpenSky 2025 (ADS-B) Example Pipeline","text":"<p>1) Aircraft sampling <code>scripts/opensky/01_aircraft_list.py</code> builds <code>data/aircraft_db.csv</code> using OpenSky Trino and the <code>typecodes</code> declared in <code>scripts/opensky/config.yaml</code>.</p> <p>2) Download raw data <code>scripts/opensky/02_download_data.py</code> fetches history, flightlist, and extended tables into <code>data/downloaded_parquet/</code>.</p> <p>3) Decode and resample <code>scripts/opensky/03_preprocess_data.py &lt;history.parquet&gt;</code> decodes BDS 4/5/6, filters short flights, computes ADEP/ADES distances, and resamples to 4 seconds.</p> <p>4) Weather enrichment and smoothing <code>scripts/opensky/04_weather_spd_process_data.py</code> adds ERA5 wind/temperature (<code>era5_features</code>), applies <code>selected_param_config</code>, and writes enriched segments to <code>data/processed_flights/&lt;TYPECODE&gt;/</code> plus <code>dataset_split.csv</code>.</p> <p>5) Train Neural ODEs <code>scripts/opensky/05_training.py</code> trains the <code>opensky_2025</code> architecture via <code>ODETrainer</code>, saving checkpoints to <code>models/opensky_&lt;TYPECODE&gt;/</code>.</p> <p>6) Inference <code>scripts/opensky/06_flight_prediction.py</code> rolls out trajectories and writes <code>pred_*</code> columns to <code>data/predicted_flights/&lt;TYPECODE&gt;/</code>.</p> <p>7) Baselines and evaluation    - <code>scripts/opensky/07_bada_prediction.py</code> (requires <code>BADA_4_2_DIR</code>)    - <code>scripts/opensky/08_visualize_predictions.py</code> (overlays for truth vs. model vs. selections vs. BADA)    - <code>scripts/opensky/09_performance_aggregation.py</code> (MAE/MAPE/ME per phase)    - <code>scripts/opensky/10_dataset_stats.py</code> (coverage statistics)</p>"},{"location":"guide/quickstart/#general-tips","title":"General Tips","text":"<ul> <li>Use the pipeline <code>config.yaml</code> (<code>scripts/opensky/config.yaml</code> or <code>scripts/qar/config.yaml</code>) as the single source of paths, typecodes, architecture names, and shared parameters.  </li> <li>Make sure caches (e.g., <code>data/era5_cache</code>) exist to avoid repeated downloads of ERA5 fields.  </li> <li>For hardware constraints, adjust <code>batch_size</code>, <code>num_workers</code>, and <code>seq_len</code> inside <code>model_config</code>.</li> </ul>"},{"location":"howto/configure_params/","title":"Configure project paths and options","text":"<p>All runtime settings are now defined per pipeline: - <code>scripts/opensky/config.yaml</code> \u2014 OpenSky 2025 pipeline - <code>scripts/qar/config.yaml</code> \u2014 QAR pipeline</p> <p>Key fields (OpenSky example): <pre><code>paths:\n  data_dir: \"/path/to/data\"\n  download_dir: \"downloaded_parquet\"\n  preprocess_dir: \"preprocessed_parquet\"\n  process_dir: \"processed_flights\"\n  predicted_dir: \"predicted_flights\"\n  bada_dir: \"bada_flights\"\n  models_dir: \"models\"\n  figure_dir: \"figures\"\n  era5_cache_dir: \"era5_cache\"\n\nera5_features:\n  - u_component_of_wind\n  - v_component_of_wind\n  - temperature\n\ntypecodes:\n  - A320\n  - A20N\n  # ...\n\nbada:\n  bada_4_2_dir: \"/path/to/BADA/4.2.1\"\n</code></pre></p> <p>Tips: - Keep <code>data_dir</code> absolute; subfolders are resolved relative to it. - Adjust <code>typecodes</code> once in the relevant <code>config.yaml</code> instead of editing scripts. - Ensure directories exist before running downloads/preprocessing (<code>mkdir -p ...</code>). - Set <code>bada.bada_4_2_dir</code> if you plan to run <code>07_bada_prediction.py</code>. - For QAR, only the needed paths are kept (<code>data_dir</code>, <code>predicted_dir</code>, <code>bada_dir</code>, <code>models_dir</code>, <code>figure_dir</code>) plus <code>typecodes</code> and <code>computing.default_cpu_count</code>.</p>"},{"location":"howto/create_architecture/","title":"Create a new architecture","text":"<p>Follow these steps to add and register a new architecture (see the README guidance):</p> <p>1) Copy a skeleton - Duplicate <code>node_fdm/architectures/opensky_2025</code> (minimal) or <code>node_fdm/architectures/qar</code> (stacked layers) into <code>node_fdm/architectures/&lt;your_arch&gt;</code>. - Keep the same file names: <code>columns.py</code>, <code>flight_process.py</code>, <code>model.py</code> (plus extra layers as needed).</p> <p>2) Declare columns (<code>columns.py</code>) - Define state (<code>X_COLS</code>), controls (<code>U_COLS</code>), environment (<code>E0_COLS</code>), derived outputs (<code>E1_COLS</code>), and derivatives (<code>DX_COLS</code>), using <code>utils.data.column.Column</code> and units. - Make sure derivative columns match the ODE targets you want to learn.</p> <p>3) Custom preprocessing (<code>flight_process.py</code>) - Implement <code>flight_processing(df)</code> to add derived columns or smoothing. - Optional <code>segment_filtering(df, start_idx, seq_len)</code> can reject bad segments (e.g., distance jumps). - Expose any config you need (e.g., <code>selected_param_config</code>).</p> <p>4) Wire the model (<code>model.py</code>) - Build <code>X_COLS</code>, <code>U_COLS</code>, <code>E0_COLS</code>, <code>E1_COLS</code>, <code>DX_COLS</code>, and <code>MODEL_COLS</code>. - Define layers (e.g., a physics/feature layer, then an ODE/data layer) and assemble <code>ARCHITECTURE</code> as a list of layer specs. - Set <code>MODEL_COLS</code> to match the ordering expected by <code>FlightProcessor</code> and <code>SeqDataset</code>.</p> <p>5) Add any custom layers - Put them in the same folder (e.g., <code>trajectory_layer.py</code>, <code>engine_layer.py</code>). - Export them via <code>__init__.py</code> if you need external imports.</p> <p>6) Register the name (<code>architectures/mapping.py</code>) - Add your key to <code>valid_names</code>. - Ensure <code>get_architecture_module</code> imports your <code>columns</code>, <code>flight_process</code>, and <code>model</code>.</p> <p>7) Test a tiny run - Prepare a minimal processed dataset conforming to your columns. - Run a short training with <code>ODETrainer</code> (small <code>seq_len</code>, small <code>batch_size</code>) to check shapes and stats. - Verify inference with <code>NodeFDMPredictor</code> using your <code>MODEL_COLS</code> and <code>flight_processing</code>.</p> <p>Tips: - Keep column names consistent between preprocessing and model definitions. - Use <code>Column</code> units to avoid silent scale bugs. - Update the relevant pipeline <code>config.yaml</code> (paths, <code>typecodes</code>) if your dataset layout differs from the existing pipelines.</p>"},{"location":"howto/run_inference/","title":"Run inference on flights (generic)","text":"<p><code>NodeFDMPredictor</code> needs: - The architecture\u2019s <code>MODEL_COLS</code> and (optionally) its <code>flight_processing</code> function. - A trained checkpoint directory containing <code>meta.json</code> and layer weights. - Processed flights that match the architecture\u2019s preprocessing.</p> <p>Example (adapt the architecture import and paths): <pre><code>import json\nfrom pathlib import Path\nimport pandas as pd\nimport yaml\n\nfrom node_fdm.predictor import NodeFDMPredictor\nfrom node_fdm.data.flight_processor import FlightProcessor\nfrom node_fdm.architectures import mapping\n\ncfg = yaml.safe_load(open(\"config.yaml\"))  # run inside scripts/opensky or scripts/qar\npaths = cfg[\"paths\"]\nprocess_dir = Path(paths[\"data_dir\"]) / paths[\"process_dir\"]\nmodels_dir = Path(paths[\"data_dir\"]) / paths[\"models_dir\"]\n\n# Load meta to recover the architecture name\nmodel_path = models_dir / \"opensky_A320\"   # replace with your model folder\nmeta = json.loads((model_path / \"meta.json\").read_text())\narch_name = meta[\"architecture_name\"]\n\n# Get architecture-specific modules\n_, model_cols, custom_fn = mapping.get_architecture_from_name(arch_name)\ncustom_processing_fn, _ = custom_fn\n\n# Prepare one processed flight\nflight_path = process_dir / \"A320\" / \"20241001_A320_00001.parquet\"\nprocessor = FlightProcessor(model_cols, custom_processing_fn=custom_processing_fn)\nf = processor.process_flight(pd.read_parquet(flight_path))\n\n# Load predictor\npredictor = NodeFDMPredictor(\n    model_cols=model_cols,\n    model_path=model_path,\n    dt=meta.get(\"step\", 4.0),\n    device=\"cuda:0\",  # set to \"cpu\" if no GPU\n)\n\n# Predict full trajectory\npred_df = predictor.predict_flight(f)\nprint(pred_df.head())\n</code></pre></p> <p><code>predict_flight</code> returns <code>pred_&lt;column&gt;</code> for each state/environment output defined by the architecture.</p> <p>Batch runs: adapt <code>scripts/opensky/06_flight_prediction.py</code> or build a small loop over your test split, reusing <code>FlightProcessor</code> + <code>NodeFDMPredictor</code>.</p>"},{"location":"howto/train_model/","title":"Train a Neural ODE model (generic)","text":"<p>Prerequisites: - A processed dataset compatible with the target architecture (columns and preprocessing must match). - A file list DataFrame with at least <code>filepath</code> and <code>split</code> (<code>train</code> / <code>val</code> / <code>test</code>).</p>"},{"location":"howto/train_model/#minimal-training-script","title":"Minimal training script","text":"<p>Set the architecture name you want to use (e.g., <code>opensky_2025</code>, <code>qar</code>, or your custom one registered in <code>architectures.mapping.valid_names</code>). <pre><code>import pandas as pd\nfrom node_fdm.ode_trainer import ODETrainer\nimport yaml\nfrom pathlib import Path\n\ncfg = yaml.safe_load(open(\"config.yaml\"))  # run inside scripts/opensky or scripts/qar\npaths = cfg[\"paths\"]\nprocess_dir = Path(paths[\"data_dir\"]) / paths[\"process_dir\"]\nmodels_dir = Path(paths[\"data_dir\"]) / paths[\"models_dir\"]\n\nacft = \"A320\"  # or any grouping key you use\narch = \"opensky_2025\"  # replace with your architecture\n\nsplit_df = pd.read_csv(process_dir / \"dataset_split.csv\")\ndata_df = split_df[split_df.aircraft_type == acft]\n\nmodel_config = dict(\n    architecture_name=arch,\n    model_name=f\"{arch}_{acft}\",\n    step=4,           # sample period (seconds)\n    shift=60,         # stride for sliding windows\n    seq_len=60,       # window length (steps)\n    lr=1e-3,\n    weight_decay=1e-4,\n    model_params=[3, 2, 48],   # architecture-specific (see model.py)\n    loading_args=(False, False),  # (load, load_loss)\n    batch_size=512,\n    num_workers=4,\n)\n\ntrainer = ODETrainer(\n    data_df=data_df,\n    model_config=model_config,\n    model_dir=models_dir,\n    num_workers=model_config[\"num_workers\"],\n    load_parallel=True,\n)\n\ntrainer.train(\n    epochs=10,\n    batch_size=model_config[\"batch_size\"],\n    val_batch_size=10_000,\n    method=\"euler\",   # or \"rk4\"\n    alpha_dict=None,  # defaults to 1.0 per monitored column\n)\n</code></pre></p> <p>Outputs in <code>models/&lt;arch&gt;_&lt;group&gt;/</code>: - <code>meta.json</code> with architecture name, stats, hyperparameters. - Layer checkpoints (e.g., <code>trajectory.pt</code>, <code>data_ode.pt</code>). - <code>training_losses.csv</code> and <code>training_curve.png</code>.</p>"},{"location":"howto/train_model/#tips","title":"Tips","text":"<ul> <li>For multiple architectures, run the loop per <code>architecture_name</code> and per data subset that matches its preprocessing/columns.</li> <li><code>model_params</code> is defined by each architecture\u2019s <code>model.py</code>; keep it in sync with your custom architecture.</li> <li>To resume training, set <code>loading_args=(True, True)</code>.</li> <li>Use <code>alpha_dict</code> in <code>trainer.train</code> to rebalance losses across monitored columns (<code>X_COLS + E_COLS</code>).</li> </ul>"},{"location":"reference/architectures/","title":"Architectures","text":""},{"location":"reference/architectures/#registry","title":"Registry","text":"<p>::: node_fdm.architectures.mapping     options:       show_root_heading: true       show_root_full_path: false       show_source: true</p>"},{"location":"reference/architectures/#opensky-2025","title":"OpenSky 2025","text":"<p>::: node_fdm.architectures.opensky_2025.columns     options:       show_root_heading: true       show_root_full_path: false       show_source: true</p> <p>::: node_fdm.architectures.opensky_2025.flight_process     options:       show_root_heading: true       show_root_full_path: false       show_source: true</p> <p>::: node_fdm.architectures.opensky_2025.model     options:       show_root_heading: true       show_root_full_path: false       show_source: true</p> <p>::: node_fdm.architectures.opensky_2025.trajectory_layer     options:       show_root_heading: true       show_root_full_path: false       show_source: true</p>"},{"location":"reference/data/","title":"Data pipeline","text":"<p>::: node_fdm.data.dataset     options:       show_root_heading: true       show_root_full_path: false       show_source: true</p> <p>::: node_fdm.data.loader     options:       show_root_heading: true       show_root_full_path: false       show_source: true</p> <p>::: node_fdm.data.flight_processor     options:       show_root_heading: true       show_root_full_path: false       show_source: true</p>"},{"location":"reference/models/","title":"Model wrappers","text":"<p>::: node_fdm.models.flight_dynamics_model     options:       show_root_heading: true       show_root_full_path: false       show_source: true</p> <p>::: node_fdm.models.batch_neural_ode     options:       show_root_heading: true       show_root_full_path: false       show_source: true</p> <p>::: node_fdm.models.flight_dynamics_model_prod     options:       show_root_heading: true       show_root_full_path: false       show_source: true</p>"},{"location":"reference/node_fdm/","title":"node_fdm package overview","text":"<p>Core namespaces and their responsibilities (all architectures share these): - <code>node_fdm.ode_trainer</code> \u2014 training loop and checkpointing for modular Neural ODEs. - <code>node_fdm.predictor</code> \u2014 inference helper to roll out trajectories. - <code>node_fdm.data</code> \u2014 dataset construction, preprocessing hooks, loaders. - <code>node_fdm.architectures</code> \u2014 architecture registry and built-in definitions (<code>opensky_2025</code>, <code>qar</code>, add your own). - <code>node_fdm.models</code> \u2014 model wrappers and ODE integration utilities.</p> <p>Use the dedicated pages in this section for full API details. If you need a top-level view of package exports:</p> <p>::: node_fdm     options:       show_root_heading: true       show_root_full_path: false       show_source: true</p>"},{"location":"reference/ode_trainer/","title":"ODE trainer","text":"<p>::: node_fdm.ode_trainer     options:       show_root_heading: true       show_root_full_path: false       show_source: true</p>"},{"location":"reference/predictor/","title":"Predictor","text":"<p>::: node_fdm.predictor     options:       show_root_heading: true       show_root_full_path: false       show_source: true</p>"}]}